[
  {
    "title": "Bun, A Revolution",
    "path": "27-04-2025/bun-a-revolution.en",
    "publishedAt": "2024-04-19T00:00:00.000Z",
    "updatedAt": "2024-05-26T00:00:00.000Z",
    "tags": [
      "Bun",
      "JavaScript",
      "Runtime",
      "Buntime",
      "TypeScript",
      "Backend",
      "Opinion",
      "New Release",
      "Announcement",
      "Node.js",
      "Deno"
    ],
    "cover": {
      "src": "/static/cover-596056c9.png",
      "height": 1000,
      "width": 1000,
      "blurDataURL": "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACwAQCdASoIAAgADMDOJbACdADca5gAAP2Y27gzhKQoPa62fbb6k/KvMlFFcwAA",
      "blurWidth": 8,
      "blurHeight": 8
    },
    "metadata": {
      "readingTime": 4,
      "wordCount": 989
    },
    "excerpt": "Bun is a Revolution in JavaScript runtimes, and you should be excited. Here's why.",
    "content": "<h2>What's Bun ?</h2>\n<p>Bun is a fresh out of the oven new runtime for JavaScript, just like NodeJS or Deno, you might know them. Now, you might know Deno already tries to solve some of the problems NodeJS has, but it's not enough. Bun not only solves all of our problems, but it also brings a lot of new features to the table.</p>\n<h2>Bun's runtime and its features</h2>\n<p>Bun 1.0 just dropped, and it's the reason for this blog post. Just know that I'm not really a guy that likes to switch to shiny new things, for example, Deno is out for a while now, but before Bun I was still using NodeJS. So you can trust me when I say that Bun's not just another shiny new thing, it's actually a revolution.</p>\n<h3>What's the problem with Node ?</h3>\n<p>You might ask, what's the problem with Node ? Yes it does work, but think of all the dependencies. Your package manager, <code>npm</code> is very slow, so you switched to <code>pnpm</code>. Because node doesn't have a watch feature you use <code>nodemon</code> (Yes I know Node 21 has a watch feature, but Node is only slowly catching up after years). You need env variables, you use <code>dotenv</code>. You need a bundler, so you use <code>esbuild</code>. You're building a big app and you want typescript, you use typescript <code>tsc</code>. You need tests, and install <code>vitest</code>.</p>\n<p>Can you believe that ? For a normal project you would use <strong>6</strong> different tools, and that might not even be all of them. That's because until recently, Node didn't understand people would actually like their tools to be bundled directly.</p>\n<h3>Bun to the rescue</h3>\n<p>Yes! Bun is here to save us from all of this. And trust me, it will be easy. Virtually any application can just be run with bun. Just replace <code>node</code> with <code>bun</code>, <code>npm</code> with <code>bun</code> and that's it. Bun 1.0 is compatible with most of the popular fullstack frameworks, and server frameworks such as Express, Koa or Hono. Bun is so fast because it doesn't use the v8 engine, it uses the JavaScript core from Webkit, which is known to be faster than v8. Also, Bun is written in Zig, which is a low-level language that is roughly as fast as C++.</p>\n<h3>ESM &#x26; CommonJS compatibility</h3>\n<p>You might know the old school require syntax, which is CommonJS and is still used a lot today, but also the new ES Modules syntax, which is a lot more modern using the import syntax. You might've ran into plenty of errors when trying to use both in the same project, such as trying to require Chalk 5 :</p>\n<pre><code class=\"language-js\">const chalk = require('chalk');\r\n// chalk - Error [ERR_REQUIRE_ESM]: require() of ES Module\n</code></pre>\n<p>That's because chalk v5 uses ES Modules, and you're trying to use it with CommonJS. Yeah I know, it's a mess. But Bun <em><strong>solves this problem</strong></em>. Yes, you heard it right, Bun is compatible with both CommonJS and ES Modules, and you can use them both in the same project. For some people, this might be just another feature, but for some others, this will be a life saver.</p>\n<h3>Web APIs</h3>\n<p>Bun provides support for the Web Standard APIs that are availab le in browsers, such as <code>fetch</code>, <code>Request</code>, <code>Response</code>, <code>WebSocket</code>, <code>ReadableStream</code>...</p>\n<pre><code class=\"language-javascript\">const res = await fetch('https://fetch.me');\r\nconst text = await res.text();\n</code></pre>\n<p>You don't need to install any package, Bun's APIs are in native code directly. This means you don't need to import anything it just works, like on the web.</p>\n<h3>Hot reloading</h3>\n<p><strong>It's not just hot reloading.</strong> Nodemon restarts the whole process when a change is detected, which is slow and not very efficient. Bun reloads your code without restarting the process, which is a lot faster. This also means that HTTP and WebSocket connections are not closed when you reload your code, which is a lot more convenient when you're working on a web app and testing things. State doesn´t change.</p>\n<h3>Bun's native APIs</h3>\n<p>Bun provides its own native APIs for thing such as the equivalent of <code>fs</code> in NodeJS. For example, in Bun, this is how you treat files :</p>\n<pre><code class=\"language-js\">// Reading files\r\nconst file = Bun.file('package.json');\r\nconst content = await file.text(); // Supports ArrayBuffer, Blob, JSON...\r\n\r\n// Writing files\r\nawait Bun.write(\"file.txt\", \"Hello world!\");\r\nawait Bun.write(\"file.txt\", Buffer.from(\"Hello world!\"));\r\nawait Bun.write(\"file.txt\", Bun.file(\"other-file.txt\"));\r\nawait Bun.write(\"file.txt\", await fetch(\"https://example.com/\"));\n</code></pre>\n<blockquote>\n<p>Bun is said to read files 10x faster than NodeJS, and write files 3x faster than NodeJS.</p>\n</blockquote>\n<p>You can also serve 4x faster HTTP servers with Bun still using the native APIs:</p>\n<pre><code class=\"language-javascript\" metastring=\"title=&#x22;index.js&#x22; showLineNumbers {4}\">Bun.serve({\r\n  port: 1234,\r\n  fetch(req) { /* ... */ },\r\n  tls: { /* ... */ },\r\n  websocket: { /* ... */ }\r\n})\n</code></pre>\n<h2>Bun's package managing</h2>\n<p>This is a part I'm really excited about. I often switch between computers to code, and I'm sure some you do too. I used to have a crappy laptop, and I had to wait <strong>many</strong> minutes to install packages. I switched to <code>pnpm</code> and it was a bit faster, but still slooow.</p>\n<p>Bun's package manager is also called using <code>bun</code>, and it's so. much. faster. I just switched to Linux on my new laptop, and I had to reinstall packages for this project, and it was lightning-fast. Usually it's slow enough that I just watch a video while installing packages...</p>\n<h2>Install Bun Now</h2>\n<p>Bun is available on Windows, Linux and macOS! You can install Bun right now. Just run this command in your terminal :</p>\n<ul>\n<li>\n<p>Windows</p>\n<pre><code class=\"language-bash\">powershell -c \"irm bun.sh/install.ps1 | iex\"\n</code></pre>\n</li>\n<li>\n<p>Linux / macOS</p>\n<pre><code class=\"language-bash\">curl -fsSL https://bun.sh/install | bash\n</code></pre>\n</li>\n</ul>\n<h2>Conclusion</h2>\n<p>I think everyone should start using Bun right now. There's no reason not to, it takes 2 minutes to setup, and it's faster. Trust me, even for things such as running scripts, the <code>150ms</code> gained feel like it's 10x faster because it feels instant and not laggy. You can check out the <a href=\"https://bun.sh/\">Bun Website</a> for more information about Bun.</p>\n<p>Thanks for reading, and see you in the next one!</p>",
    "toc": [
      {
        "title": "What's Bun ?",
        "url": "#whats-bun-",
        "items": []
      },
      {
        "title": "Bun's runtime and its features",
        "url": "#buns-runtime-and-its-features",
        "items": [
          {
            "title": "What's the problem with Node ?",
            "url": "#whats-the-problem-with-node-",
            "items": []
          },
          {
            "title": "Bun to the rescue",
            "url": "#bun-to-the-rescue",
            "items": []
          },
          {
            "title": "ESM & CommonJS compatibility",
            "url": "#esm--commonjs-compatibility",
            "items": []
          },
          {
            "title": "Web APIs",
            "url": "#web-apis",
            "items": []
          },
          {
            "title": "Hot reloading",
            "url": "#hot-reloading",
            "items": []
          },
          {
            "title": "Bun's native APIs",
            "url": "#buns-native-apis",
            "items": []
          }
        ]
      },
      {
        "title": "Bun's package managing",
        "url": "#buns-package-managing",
        "items": []
      },
      {
        "title": "Install Bun Now",
        "url": "#install-bun-now",
        "items": []
      },
      {
        "title": "Conclusion",
        "url": "#conclusion",
        "items": []
      }
    ],
    "uniqueId": "27-04-2025",
    "slug": "bun-a-revolution.en",
    "locale": "en"
  },
  {
    "title": "Bun, une Révolution",
    "path": "27-04-2025/bun-une-revolution.fr",
    "publishedAt": "2024-04-19T00:00:00.000Z",
    "updatedAt": "2024-05-26T00:00:00.000Z",
    "tags": [
      "Bun",
      "JavaScript",
      "Runtime",
      "Buntime",
      "TypeScript",
      "Backend",
      "Opinion",
      "Nouvelle Version",
      "Annonce",
      "Node.js",
      "Deno"
    ],
    "cover": {
      "src": "/static/cover-596056c9.png",
      "height": 1000,
      "width": 1000,
      "blurDataURL": "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACwAQCdASoIAAgADMDOJbACdADca5gAAP2Y27gzhKQoPa62fbb6k/KvMlFFcwAA",
      "blurWidth": 8,
      "blurHeight": 8
    },
    "metadata": {
      "readingTime": 4,
      "wordCount": 1089
    },
    "excerpt": "Bun est une révolution dans les runtimes JavaScript, et vous vous devez d'être excités. Voici pourquoi.",
    "content": "<h2>C'est quoi Bun ?</h2>\n<p>Bun est un tout nouveau runtime pour JavaScript, tout comme NodeJS ou Deno, que vous connaissez peut-être. Maintenant, vous savez peut-être que Deno essaie déjà de résoudre certains des problèmes de NodeJS, mais ce n'est pas suffisant. Bun ne résout pas seulement tous nos problèmes, mais il apporte également de nombreuses nouvelles fonctionnalités.</p>\n<h2>Le runtime de Bun et ses fonctionnalités</h2>\n<p>Bun 1.0 vient de sortir, et c'est la raison de ce post de blog. Sachez que je ne suis pas vraiment quelqu'un qui aime passer aux dernières nouvelles technologies, par exemple, Deno est sorti il y a un moment, mais avant Bun, j'utilisais toujours NodeJS. Vous pouvez me faire confiance quand je dis que Bun n'est pas juste un autre nouveau truc, c'est en fait une révolution.</p>\n<h3>C'est quoi le problème avec Node ?</h3>\n<p>Vous pourriez demander, quel est le problème avec Node ? Oui, ça fonctionne, mais pensez à toutes les dépendances. Votre gestionnaire de paquets, <code>npm</code> est très lent, vous passez alors à <code>pnpm</code>. Parce que Node n'a pas de watcher, vous utilisez <code>nodemon</code> (Oui je sais que Node 21 a un watcher, mais Node se rattrape lentement après des années). Vous avez besoin de variables d'environnement, vous utilisez <code>dotenv</code>. Vous avez besoin d'un bundler, donc vous utilisez <code>esbuild</code>. Vous construisez une grande application et vous voulez typescript, vous utilisez typescript <code>tsc</code>. Vous avez besoin de tests, et installez <code>vitest</code>.</p>\n<p>Vous y croyez ? Pour un projet normal, vous utiliseriez <strong>6</strong> outils différents, et ce n'est peut-être même pas tout. C'est parce que jusqu'à récemment, Node ne comprenait pas que les gens aimeraient que leurs outils soient directement regroupés.</p>\n<h3>Bun à la rescousse</h3>\n<p>Oui ! Bun est là pour nous sauver de tout cela. Et croyez-moi, ce sera facile. Virtuellement n'importe quelle application peut être exécutée avec bun. Remplacez simplement <code>node</code> par <code>bun</code>, <code>npm</code> par <code>bun</code> et c'est tout. Bun 1.0 est compatible avec la plupart des frameworks fullstack populaires, et les frameworks serveur tels qu'Express, Koa ou Hono. Bun est si rapide parce qu'il n'utilise pas le moteur v8, il utilise le noyau JavaScript de Webkit, qui est connu pour être plus rapide que v8. De plus, Bun est écrit en Zig, qui est un langage de bas niveau qui est à peu près aussi rapide que C++.</p>\n<h3>Compatibilité ESM &#x26; CommonJS</h3>\n<p>Vous connaissez peut-être la syntaxe require de l'ancienne école, qui se nomme CommonJS et est encore beaucoup utilisée aujourd'hui, mais aussi la nouvelle syntaxe ES Modules, qui est beaucoup plus moderne en utilisant la syntaxe d'importation. Vous avez peut-être rencontré de nombreuses erreurs en essayant d'utiliser les deux dans le même projet, comme en essayant de require Chalk 5 :</p>\n<pre><code class=\"language-js\">const chalk = require('chalk');\r\n// chalk - Error [ERR_REQUIRE_ESM]: require() of ES Module\n</code></pre>\n<p>C'est parce que chalk v5 utilise les ES Modules, et vous essayez de l'utiliser avec CommonJS. Oui, je sais, c'est un gâchis. Mais Bun <em><strong>résout ce problème</strong></em>. Oui, vous avez bien entendu, Bun est compatible avec CommonJS et ES Modules, et vous pouvez les utiliser tous les deux dans le même projet. Pour certaines personnes, ce n'est peut-être qu'une autre fonctionnalité, mais pour d'autres, ce sera un sauveur de vie.</p>\n<h3>APIs Web</h3>\n<p>Bun fournit un support pour les APIs Web Standard qui sont disponibles dans les navigateurs, telles que <code>fetch</code>, <code>Request</code>, <code>Response</code>, <code>WebSocket</code>, <code>ReadableStream</code>...</p>\n<pre><code class=\"language-js\">const res = await fetch('https://fetch.me');\r\nconst text = await res.text();\n</code></pre>\n<p>Vous n'avez pas besoin d'installer de package, les APIs de Bun sont directement en code natif. Cela signifie que vous n'avez pas besoin d'importer quoi que ce soit, cela fonctionne juste, comme sur le web.</p>\n<h3>Rechargement à chaud</h3>\n<p><strong>Ce n'est pas juste un rechargement à chaud.</strong> Nodemon redémarre tout le processus lorsqu'un changement est détecté, ce qui est lent et pas très efficace. Bun recharge votre code sans redémarrer le processus, ce qui est beaucoup plus rapide. Cela signifie également que les connexions HTTP et WebSocket ne sont pas fermées lorsque vous rechargez votre code, ce qui est beaucoup plus pratique lorsque vous travaillez sur une application web et que vous testez des choses. Les states ne changent pas.</p>\n<h3>APIs natives de Bun</h3>\n<p>Bun fournit ses propres APIs natives pour des choses telles que l'équivalent de <code>fs</code> dans NodeJS. Par exemple, dans Bun, voici comment vous traitez les fichiers :</p>\n<pre><code class=\"language-js\">// Lecture de fichiers\r\nconst file = Bun.file('package.json');\r\nconst content = await file.text(); // Supporte ArrayBuffer, Blob, JSON...\r\n\r\n// Écriture de fichiers\r\nawait Bun.write(\"file.txt\", \"Hello world!\");\r\nawait Bun.write(\"file.txt\", Buffer.from(\"Hello world!\"));\r\nawait Bun.write(\"file.txt\", Bun.file(\"other-file.txt\"));\r\nawait Bun.write(\"file.txt\", await fetch(\"https://example.com/\"));\n</code></pre>\n<blockquote>\n<p>Bun est dit lire les fichiers 10x plus rapidement que NodeJS, et écrire les fichiers 3x plus rapidement que NodeJS.</p>\n</blockquote>\n<p>Vous pouvez également servir des serveurs HTTP 4x plus rapides avec Bun en utilisant toujours les APIs natives :</p>\n<pre><code class=\"language-js\">Bun.serve({\r\n  port: 1234,\r\n  fetch(req) { /* ... */ },\r\n  tls: { /* ... */ },\r\n  websocket: { /* ... */ }\r\n})\n</code></pre>\n<h3>Gestion des paquets de Bun</h3>\n<p>C'est une partie qui m'excite vraiment. Je passe souvent d'un ordinateur à l'autre pour coder, et je suis sûr que certains d'entre vous aussi. J'avais l'habitude d'avoir un ordinateur portable pourri, et je devais attendre <strong>beaucoup</strong> de temps pour installer des paquets. J'ai basculé vers <code>pnpm</code> et c'était un peu plus rapide, mais toujours lent.</p>\n<p>Le gestionnaire de paquets de Bun est également appelé en utilisant <code>bun</code>, et c'est beaucoup. beaucoup. plus rapide. Je viens de passer sur Linux sur mon nouveau pc portable, j'ai dû réinstaller les paquets pour ce projet, et c'était ultra-rapide. Habituellement, c'est assez lent pour que je regarde une vidéo pendant l'installation des paquets...</p>\n<h3>Installez Bun maintenant</h3>\n<p>Bun est disponible sur Windows, Linux et macOS ! Vous pouvez installer Bun dès maintenant. Exécutez simplement cette commande dans votre terminal :</p>\n<ul>\n<li>\n<p>Windows</p>\n<pre><code class=\"language-bash\">powershell -c \"irm bun.sh/install.ps1 | iex\"\n</code></pre>\n</li>\n<li>\n<p>Linux / macOS</p>\n<pre><code class=\"language-bash\">curl -fsSL https://bun.sh/install | bash\n</code></pre>\n</li>\n</ul>\n<h2>Conclusion</h2>\n<p>Je pense que tout le monde devrait commencer à utiliser Bun dès maintenant. Il n'y a aucune raison de ne pas le faire, cela prend 2 minutes à configurer, et c'est plus rapide. Faites-moi confiance, même pour des choses telles que l'exécution de scripts, les <code>150ms</code> gagnées semblent être 10x plus rapides car cela semble instantané et non lentes. Vous pouvez consulter le <a href=\"https://bun.sh/\">site Web de Bun</a> pour plus d'informations sur Bun.</p>\n<p>Merci d'avoir lu, et passez une bonne journée.</p>",
    "toc": [
      {
        "title": "C'est quoi Bun ?",
        "url": "#cest-quoi-bun-",
        "items": []
      },
      {
        "title": "Le runtime de Bun et ses fonctionnalités",
        "url": "#le-runtime-de-bun-et-ses-fonctionnalités",
        "items": [
          {
            "title": "C'est quoi le problème avec Node ?",
            "url": "#cest-quoi-le-problème-avec-node-",
            "items": []
          },
          {
            "title": "Bun à la rescousse",
            "url": "#bun-à-la-rescousse",
            "items": []
          },
          {
            "title": "Compatibilité ESM & CommonJS",
            "url": "#compatibilité-esm--commonjs",
            "items": []
          },
          {
            "title": "APIs Web",
            "url": "#apis-web",
            "items": []
          },
          {
            "title": "Rechargement à chaud",
            "url": "#rechargement-à-chaud",
            "items": []
          },
          {
            "title": "APIs natives de Bun",
            "url": "#apis-natives-de-bun",
            "items": []
          },
          {
            "title": "Gestion des paquets de Bun",
            "url": "#gestion-des-paquets-de-bun",
            "items": []
          },
          {
            "title": "Installez Bun maintenant",
            "url": "#installez-bun-maintenant",
            "items": []
          }
        ]
      },
      {
        "title": "Conclusion",
        "url": "#conclusion",
        "items": []
      }
    ],
    "uniqueId": "27-04-2025",
    "slug": "bun-une-revolution.fr",
    "locale": "fr"
  }
]